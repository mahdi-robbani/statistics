par0 <- par0 - k*gmllk(par0, S)  ##gradient descent update
points(par0[1], par0[2], col = "red", lwd = 1)
arrows(x0 = parOld[1], y0 = parOld[2] , x1 = par0[1], y1 = par0[2],
col = "red",length = 0.01, lwd = 1 )
}
Z
z
Z <- matrix(data = z, byrow = T, nrow = 100)
contour(x = mu_grid, y = sigma_grid, z = Z, xlab = "mu", ylab = "sigma",
main = paste0("Contour plot of  minus log likelihood"))
par0 <- c(3, 8) ##initial parameters guess
k <- 0.01 ## learning rate of gradient descent
M <- 40 ## max num of iterations
for (i in 1:M){
parOld <- par0
par0 <- par0 - k*gmllk(par0, S)  ##gradient descent update
points(par0[1], par0[2], col = "red", lwd = 1)
arrows(x0 = parOld[1], y0 = parOld[2] , x1 = par0[1], y1 = par0[2],
col = "red",length = 0.01, lwd = 1 )
}
Z <- matrix(data = z, byrow = F, nrow = 50)
contour(x = mu_grid, y = sigma_grid, z = Z, xlab = "mu", ylab = "sigma",
main = paste0("Contour plot of  minus log likelihood"))
Z <- matrix(data = z, byrow = T, nrow = 50)
contour(x = mu_grid, y = sigma_grid, z = Z, xlab = "mu", ylab = "sigma",
main = paste0("Contour plot of  minus log likelihood"))
Z <- matrix(data = z, byrow = F, nrow = 100)
contour(x = mu_grid, y = sigma_grid, z = Z, xlab = "mu", ylab = "sigma",
main = paste0("Contour plot of  minus log likelihood"))
par0 <- c(3, 8) ##initial parameters guess
k <- 0.01 ## learning rate of gradient descent
M <- 40 ## max num of iterations
for (i in 1:M){
parOld <- par0
par0 <- par0 - k*gmllk(par0, S)  ##gradient descent update
points(par0[1], par0[2], col = "red", lwd = 1)
arrows(x0 = parOld[1], y0 = parOld[2] , x1 = par0[1], y1 = par0[2],
col = "red",length = 0.01, lwd = 1 )
}
Z <- matrix(data = z, byrow = T, nrow = 100)
contour(x = mu_grid, y = sigma_grid, z = Z, xlab = "mu", ylab = "sigma",
main = paste0("Contour plot of  minus log likelihood"))
par0 <- c(3, 8) ##initial parameters guess
k <- 0.01 ## learning rate of gradient descent
M <- 40 ## max num of iterations
for (i in 1:M){
parOld <- par0
par0 <- par0 - k*gmllk(par0, S)  ##gradient descent update
points(par0[1], par0[2], col = "red", lwd = 1)
arrows(x0 = parOld[1], y0 = parOld[2] , x1 = par0[1], y1 = par0[2],
col = "red",length = 0.01, lwd = 1 )
}
#gradient descent
#### plotting the contour plot
mu_grid <- seq(-9.9, 9.9, 0.2)
sigma_grid <- seq(0, 9.8, 0.1)
grid <- expand.grid(mu_grid, sigma_grid)
z <- apply(grid, MARGIN = 1, mllk, data = S)
Z <- matrix(data = z, byrow = T, nrow = 100)
contour(x = mu_grid, y = sigma_grid, z = Z, xlab = "mu", ylab = "sigma",
main = paste0("Contour plot of  minus log likelihood"))
Z <- matrix(data = z, byrow = F, nrow = 100)
contour(x = mu_grid, y = sigma_grid, z = Z, xlab = "mu", ylab = "sigma",
main = paste0("Contour plot of  minus log likelihood"))
#gradient descent
#### plotting the contour plot
mu_grid <- seq(-9.9, 9.9, 0.2)
sigma_grid <- seq(0, 9.8, 0.4)
grid <- expand.grid(mu_grid, sigma_grid)
z <- apply(grid, MARGIN = 1, mllk, data = S)
Z <- matrix(data = z, byrow = F, nrow = 100)
contour(x = mu_grid, y = sigma_grid, z = Z, xlab = "mu", ylab = "sigma",
main = paste0("Contour plot of  minus log likelihood"))
#gradient descent
#### plotting the contour plot
mu_grid <- seq(-9.9, 9.9, 0.2)
sigma_grid <- seq(0, 9.8, 1)
grid <- expand.grid(mu_grid, sigma_grid)
z <- apply(grid, MARGIN = 1, mllk, data = S)
Z <- matrix(data = z, byrow = F, nrow = 100)
contour(x = mu_grid, y = sigma_grid, z = Z, xlab = "mu", ylab = "sigma",
main = paste0("Contour plot of  minus log likelihood"))
mu_grid <- seq(-9.9, 9.9, 0.2)
sigma_grid <- seq(0, 9.8, 1)
grid <- expand.grid(mu_grid, sigma_grid)
z <- apply(grid, MARGIN = 1, mllk, data = S)
Z <- matrix(data = z, byrow = F, nrow = 100)
contour(x = mu_grid, y = sigma_grid, z = Z, xlab = "mu", ylab = "sigma",
levels = quantile(z, probs = seq(from = 0, to =1, by = 0.05)),
main = paste0("Contour plot of  minus log likelihood"))
par0 <- c(3, 8) ##initial parameters guess
k <- 0.01 ## learning rate of gradient descent
M <- 40 ## max num of iterations
for (i in 1:M){
parOld <- par0
par0 <- par0 - k*gmllk(par0, S)  ##gradient descent update
points(par0[1], par0[2], col = "red", lwd = 1)
arrows(x0 = parOld[1], y0 = parOld[2] , x1 = par0[1], y1 = par0[2],
col = "red",length = 0.01, lwd = 1 )
}
mu_grid <- seq(-9.9, 9.9, 0.2)
sigma_grid <- seq(0, 9.8, 1)
grid <- expand.grid(mu_grid, sigma_grid)
z <- apply(grid, MARGIN = 1, mllk, data = S)
Z <- matrix(data = z, byrow = F, nrow = 100)
contour(x = mu_grid, y = sigma_grid, z = Z, xlab = "mu", ylab = "sigma",
levels = quantile(z, probs = seq(from = 0, to =1, by = 0.1)),
main = paste0("Contour plot of  minus log likelihood"))
par0 <- c(3, 8) ##initial parameters guess
k <- 0.01 ## learning rate of gradient descent
M <- 40 ## max num of iterations
for (i in 1:M){
parOld <- par0
par0 <- par0 - k*gmllk(par0, S)  ##gradient descent update
points(par0[1], par0[2], col = "red", lwd = 1)
arrows(x0 = parOld[1], y0 = parOld[2] , x1 = par0[1], y1 = par0[2],
col = "red",length = 0.01, lwd = 1 )
}
#gradient descent
#### plotting the contour plot
mu_grid <- seq(-9.9, 9.9, 0.2)
sigma_grid <- seq(0, 9.8, 1)
grid <- expand.grid(mu_grid, sigma_grid)
z <- apply(grid, MARGIN = 1, mllk, data = S)
Z <- matrix(data = z, byrow = F, nrow = 100)
contour(x = mu_grid, y = sigma_grid, z = Z, xlab = "mu", ylab = "sigma",
levels = quantile(z, probs = seq(from = 0, to =1, by = 0.1)),
main = paste0("Contour plot of  minus log likelihood"))
quantile(z, probs = seq(from = 0, to =1, by = 0.1))
#gradient descent
#### plotting the contour plot
#mu_grid <- seq(-9.9, 9.9, 0.2)
#sigma_grid <- seq(0, 9.8, 1)
mu_grid <- seq(from = -10, to = 10, length.out = 100)
sigma_grid <- seq(from = 1, to = 10, length.out = 100  )
grid <- expand.grid(mu_grid, sigma_grid)
z <- apply(grid, MARGIN = 1, mllk, data = S)
Z <- matrix(data = z, byrow = F, nrow = 100)
contour(x = mu_grid, y = sigma_grid, z = Z, xlab = "mu", ylab = "sigma",
levels = quantile(z, probs = seq(from = 0, to =1, by = 0.1)),
main = paste0("Contour plot of  minus log likelihood"))
quantile(z, probs = seq(from = 0, to =1, by = 0.1))
#JB
temp <- seq(20, 60, length.out = 100)
nisin <- seq(0, 80, length.out = 100)
data_grid <- expand.grid(temp, nisin
data_grid
data_grid <- expand.grid(temp, nisin)
data_grid
data_grid$ph <- 5
data_grid$brix <- 14
pred_grid <- predict(apple_model2, newdata = data_grid, type = "response")
#JB
temp <- seq(20, 60, length.out = 100)
nisin <- seq(0, 80, length.out = 100)
data_grid <- expand.grid(temp, nisin)
data_grid$ph <- 5
data_grid$brix <- 14
data_grid
pred_grid <- predict(apple_model2, newdata = data_grid, type = "response")
temp
predict(apple_model2, newdata = data_grid, type = "response")
data_grid
apple_model2
data_grid
data_grid <- expand.grid(temp = temp, nisin = nisin)
data_grid$ph <- 5
data_grid$brix <- 14
pred_grid <- predict(apple_model2, newdata = data_grid, type = "response")
pred_mat <- matrix(pred_grid, nrow=100, byrow = TRUE)
filled.contour(seq(20, 60, length.out = 100), seq(0, 80, length.out = 100), pred_mat, levels = quantile(pred_mat, probs = seq(0,1,0.05)))
filled.contour(seq(20, 60, length.out = 100), seq(0, 80, length.out = 100), pred_mat, levels = quantile(pred_mat, probs = seq(0,1,0.1)))
filled.contour(seq(20, 60, length.out = 100), seq(0, 80, length.out = 100), pred_mat, levels = quantile(pred_mat, probs = seq(0,1,0.1)), xlab= "Temperature", ylab = "Nisin concentration")
filled.contour(seq(20, 60, length.out = 100), seq(0, 80, length.out = 100), pred_mat, levels = quantile(pred_mat, probs = seq(0,1,0.1)), xlab= "Temperature", ylab = "Nisin concentration", main = "Contour plot of advanced model")
pred_mat
pred_mat[50][50]
pred_mat[50]
pred_mat[50,]
pred_grid
pred_grid[5000]
plot(pred_grid)
plot(density(obs), sub = "kernel density estimations", xlab = "", main = "",
ylim = c(0, 0.06))
for (bw in seq(2,5,1)){
lines(density(trees$Volume, bw = bw), col = bw  )
}
plot(density(obs), sub = "kernel density estimations", xlab = "", main = "",
ylim = c(0, 0.06))
for (bw in seq(2,5,1)){
lines(density(obs, bw = bw), col = bw  )
}
plot(density(obs), sub = "kernel density estimations", xlab = "", main = "", )
for (bw in seq(2,5,1)){
lines(density(obs, bw = bw), col = bw  )
}
for (bw in seq(0,2, 0.5)){
lines(density(obs, bw = bw), col = bw  )
}
for (bw in seq(0.5,2, 0.5)){
lines(density(obs, bw = bw), col = bw  )
}
###
plot(density(obs), sub = "kernel density estimations", xlab = "", main = "", )
for (bw in seq(0.5,2, 0.5)){
lines(density(obs, bw = bw), col = bw  )
}
for (bw in seq(0.5,2, 0.5)){
lines(density(obs, bw = bw), col = bw*2  )
}
###
plot(density(obs), sub = "kernel density estimations", xlab = "", main = "", )
for (bw in seq(0.5,2, 0.5)){
lines(density(obs, bw = bw), col = bw*2  )
}
hist(obs, breaks = 10, probability = TRUE)
obs
hist(obs, probability = TRUE)
hist(obs, probability = TRUE)
for (bw in seq(0.5,2, 0.5)){
lines(density(obs, bw = bw), col = bw*2  )
}
hist(obs, breaks = 5, probability = TRUE)
for (bw in seq(0.5,2, 0.5)){
lines(density(obs, bw = bw), col = bw*2  )
}
hist(obs, breaks = 10, probability = TRUE)
for (bw in seq(0.5,2, 0.5)){
lines(density(obs, bw = bw), col = bw*2  )
}
hist(obs, breaks = 20, probability = TRUE)
for (bw in seq(0.5,2, 0.5)){
lines(density(obs, bw = bw), col = bw*2  )
}
hist(obs, breaks = 15, probability = TRUE)
hist(obs, breaks = 10, probability = TRUE)
for (bw in seq(0.5,2, 0.5)){
lines(density(obs, bw = bw), col = bw*2  )
}
hist(obs, probability = TRUE)
hist(obs, breaks = 10, probability = TRUE)
for (bw in seq(0.5,2, 0.5)){
lines(density(obs, bw = bw), col = bw*2  )
}
legend("topright", seq(0.5,2,0.5), col = seq(0.5,2,0.5)*2))
legend("topright", seq(0.5,2,0.5), col = seq(0.5,2,0.5)*2)
legend("topright", c(seq(0.5,2,0.5)), col = seq(0.5,2,0.5)*2)
legend("topright", c("0.5","1", "1.5", "2"), col = seq(0.5,2,0.5)*2)
legend("topright", c("0.5","1", "1.5", "2"), col = seq(0.5,2,0.5)*2, lty = 1)
hist(obs, breaks = 20, probability = TRUE)
for (bw in seq(0.5,2, 0.5)){
lines(density(obs, bw = bw), col = bw*2  )
}
hist(obs, breaks = 10, probability = TRUE)
for (bw in seq(0.5,2, 0.5)){
lines(density(obs, bw = bw), col = bw*2  )
}
legend("topright", c("0.5","1", "1.5", "2"), col = seq(0.5,2,0.5)*2, lty = 1)
plot(ecdf(obs))
?ecdf
quantile(sort(obs))
paste("1st quantile:", q[2])
q <- data.frame(Quantile = c("1st quantile", "1nd quantile", "3rd quantile"),
Value = quantile(sort(obs))[2:4])
q
plot(ecdf(obs))
lines(ecdf(obs), col = "red")
ecdf(obs)
density(ecdf(obs))
ecdf(obs)
x<- ecdf(obs)
x
curve(x)
plot(ecdf(obs))
curve(x, add = TRUE)
lines(ecdf(rnorm(10)),col='blue')
plot(ecdf(rnorm(20)),col='red')
lines(ecdf(rnorm(10)),col='blue')
plot(ecdf(rnorm(20)),col='red')
curv(dnorm(x))
plot(ecdf(rnorm(20)),col='red')
curve(dnorm(x))
curve(pnorm(x))
plot(ecdf(rnorm(20)),col='red')
curve(pnorm(x))
plot(ecdf(rnorm(20)),col='red')
curve(pnorm(x), add = TRUE)
plot(ecdf(obs))
?plot
plot(ecdf(obs), main = "ECDF plot of obs")
summary(obs)
hist(obs, breaks = 10, probability = TRUE)
curve(dnorm(x, mean = mean(obs), sd = sd(obs)), add = TRUE, col = "blue")
curve(dlnorm(x, meanlog = log(mean(obs)), sd = log(sd(obs))), add = TRUE, col = "darkgreen")
curve(dgamma(x, shape = parametersGamma[1], rate = parametersGamma[2]), add = TRUE, col = "red")
curve(dexp(x, rate = 1/mean(obs)), add = TRUE, col = "darkred")
legend("topright", c("Normal dist", "Log Normal dist", "Gamma dist", "Exp dist"), col = c("blue", "darkgreen", "red", "darkred"), lty = 1)
curve(dexp(x, rate = 1/mean(obs)), add = TRUE, col = "yellow")
curve(dexp(x, rate = 1/mean(obs)), add = TRUE, col = "green")
curve(dlnorm(x, meanlog = log(mean(obs)), sd = log(sd(obs))), add = TRUE, col = "purple")
curve(dexp(x, rate = 1/mean(obs)), add = TRUE, col = "darkgreen")
hist(obs, breaks = 10, probability = TRUE)
curve(dnorm(x, mean = mean(obs), sd = sd(obs)), add = TRUE, col = "blue")
curve(dlnorm(x, meanlog = log(mean(obs)), sd = log(sd(obs))), add = TRUE, col = "purple")
curve(dgamma(x, shape = parametersGamma[1], rate = parametersGamma[2]), add = TRUE, col = "red")
curve(dexp(x, rate = 1/mean(obs)), add = TRUE, col = "darkgreen")
legend("topright", c("Normal dist", "Log Normal dist", "Gamma dist", "Exp dist"), col = c("blue", "purple", "red", "darkgreen"), lty = 1)
curve(dlnorm(x, meanlog = mean(log(obs)), sd = sd(log(obs)), add = TRUE, col = "purple")
curve(dlnorm(x, meanlog = mean(log(obs)), sd = sd(log(obs)), add = TRUE, col = "purple"))
curve(dlnorm(x, meanlog = mean(log(obs)), sd = sd(log(obs)), add = TRUE, col = "purple"))
curve(dlnorm(x, meanlog = mean(log(obs)), sd = sd(log(obs))), add = TRUE, col = "purple")
curve(dlnorm(x, meanlog = mean(log(obs)), sd = sd(log(obs))), add = TRUE, col = "red")
qqnorm(obs)
qqline(obs, col = "red")
qqplot(sort(obs), qexp(ppoints(obs), rate = 1/mean(obs)), xlab = "Theoretical Quantiles", ylab = "Sample Quantiles", main = "Q-Q plot")
abline(0, 1, col = "red")
qqnorm(obs)
qqline(obs, col = "red")
qqplot(sort(obs), qexp(ppoints(obs), rate = 1/mean(obs)), xlab = "Theoretical Quantiles", ylab = "Sample Quantiles", main = "Exponential Q-Q plot")
abline(0, 1, col = "red")
qqnorm(rnorm(100))
qqline(rnorm(100))
qqnorm(obs)
qqline(obs, col = "red")
qqplot(sort(obs), qexp(ppoints(obs), rate = 1/mean(obs)), xlab = "Theoretical Quantiles", ylab = "Sample Quantiles", main = "Exponential Q-Q plot")
abline(0, 1, col = "red")
qqnorm(rnorm(100))
qqline(rnorm(100))
qqplot(sort(obs), qexp(ppoints(obs), rate = 1/mean(obs)), xlab = "Theoretical Quantiles", ylab = "Sample Quantiles", main = "Exponential Q-Q plot")
abline(0, 1, col = "red")
qqplot(qexp(ppoints(obs), rate = 1/mean(obs)), sort(obs), xlab = "Theoretical Quantiles", ylab = "Sample Quantiles", main = "Exponential Q-Q plot")
abline(0, 1, col = "red")
qqnorm(obs)
qqline(obs, col = "red")
qqplot(qexp(ppoints(obs), rate = 1/mean(obs)), sort(obs), xlab = "Theoretical Quantiles", ylab = "Sample Quantiles", main = "Exponential Q-Q plot")
abline(0, 1, col = "red")
sum(dexp(obs, rate = 1/mean(obs), log = TRUE))
valueGamma
loglikeExp <- sum(dexp(obs, rate = 1/mean(obs), log = TRUE))
loglikeGamma <- -valueGamma
delta <- -2 * (loglikeExp - loglikeGamma)
pvalue <- pchisq(delta, lower.tail = FALSE, df = 1)
pvalue
loglikeExp <- sum(dexp(obs, rate = 1/mean(obs), log = TRUE))
loglikeGamma <- -valueGamma
delta <- -2 * (loglikeExp - loglikeGamma)
pvalue <- pchisq(delta, lower.tail = FALSE, df = 1)
pvalue
#create list of models
models <- list(Normal = dnorm(obs, mean = mean(obs), sd = sd(obs), log= TRUE),
LogNormal = dlnorm(obs, meanlog = mean(log(obs)), sd = log(sd(obs)),
log = TRUE),
Gamma = dgamma(obs, shape = parametersGamma[1], rate = parametersGamma[2],
log = TRUE),
Exponential = dexp(obs, rate = 1/mean(obs), log = TRUE))
#calculate AIC
AIC <- sapply(models, function(x) -2*sum(x) + 2*2)
AIC[4] <- AIC[4] - 1 #Exponential dist only has one parameter, so adjust
AIC
qnorm(0.05 / 2, lower.tail = FALSE)
qnorm(1-0.05/2)
z <- qnorm(1-0.05/2)
lambda <- 1/(mean(obs))
n <- length(obs)
cbind("2.5%" = lambda - lambda/(sqrt(length(obs))) * z,
"97.5%" = lambda + lambda/(sqrt(length(obs))) * z)
z <- qnorm(1-0.05/2)
lambda <- 1/(mean(obs))
n <- length(obs)
cbind("2.5%" = lambda - lambda/(sqrt(n)) * z,
"97.5%" = lambda + lambda/(sqrt(n)) * z)
wald <- abs((lambda-0.5)/sqrt(n))
wald
qnorm(0.05)
alpha <- 0.05
z <- qnorm(1-alpha/2)
lambda <- 1/(mean(obs))
n <- length(obs)
CI <- cbind("2.5%" = lambda - lambda/(sqrt(n)) * z, #apply the formula
"97.5%" = lambda + lambda/(sqrt(n)) * z)
CI #Confidence interval
alpha <- 0.05
z <- qnorm(1-alpha/2)
lambda <- 1/(mean(obs))
n <- length(obs)
se <- lambda/sqrt(n)
CI <- cbind("2.5%" = lambda - z * se, #apply the formula
"97.5%" = lambda + z * se)
CI #Confidence interval
wald <- abs((lambda-0.5)/sqrt(n))
wald
#wald <- (abs((lambda-0.5)/sqrt(n)))
wald <- (lambda_est - 0.5) / se_est
#calculate values
alpha <- 0.05
z <- qnorm(1 - alpha/2)
lambda_est <- 1/(mean(obs))
n <- length(obs)
se_est <- lambda_est/sqrt(n)
#apply the formula
CI <- cbind("2.5%" = lambda_est - z * se_est,
"97.5%" = lambda_est + z * se_est)
CI #Confidence interval
#wald <- (abs((lambda-0.5)/sqrt(n)))
wald <- (lambda_est - 0.5) / se_est
wald
#wald <- (abs((lambda-0.5)/sqrt(n)))
wald <- (lambda_est - 0.5) / se_est
pval <- 2 * pnorm(-abs(wald))
pval
#2.1
head(applejuice)
applejuice_test
applejuice$growth <- as.factor(applejuice$growth)
apple_model <- glm(growth ~ ., family = "binomial", data = applejuice)
summary(apple_model)
apple_model2 <- update(apple_model, . ~ . + I(brix * ph) + I(brix * temp) + I(brix * nisin))
summary(apple_model2)
AIC(apple_model, apple_model2)
BIC(apple_model, apple_model2)
anova(apple_simple, apple_advanced, test="LRT")
applejuice$growth <- as.factor(applejuice$growth)
apple_simple <- glm(growth ~ ., family = "binomial", data = applejuice)
summary(apple_simple)
applejuice$growth <- as.factor(applejuice$growth)
apple_simple <- glm(growth ~ ., family = "binomial", data = applejuice)
summary(apple_simple)
apple_advanced <- update(apple_simple, . ~ . + I(brix * ph) + I(brix * temp) + I(brix * nisin))
summary(apple_advanced)
anova(apple_simple, apple_advanced, test="LRT")
anova(apple_simple, apple_advanced, test="LRT")
confint(apple_simple, level = 0.99)
a1_pred <- predict(apple_simple, newdata = applejuice_test, type = "response")
a2_pred <- predict(apple_advanced, newdata = applejuice_test, type = "response")
apple_predictions <- data.frame(apple_simple = a1_pred,
apple_advanced = a2_pred,
test_data = applejuice_test$growth_p)
apple_predictions
data_grid
#create data
temp <- seq(20, 60, length.out = 100)
nisin <- seq(0, 80, length.out = 100)
data_grid <- expand.grid(temp = temp, nisin = nisin)
data_grid$ph <- 5
data_grid$brix <- 14
pred_grid <- predict(apple_advanced, newdata = data_grid, type = "response")
pred_mat <- matrix(pred_grid, nrow=100, byrow = TRUE)
filled.contour(seq(20, 60, length.out = 100), seq(0, 80, length.out = 100), pred_mat, levels = quantile(pred_mat, probs = seq(0,1,0.1)), xlab= "Temperature", ylab = "Nisin concentration", main = "Contour plot of advanced model")
data_grid
data_grid
pred_grid
## 3.1
hist(brainhead$brainweight)
qqnorm(brainhead$brainweight)
qqline(brainhead$brainweight, col = "red")
brainweight <- brainhead$brainweight
hist(brainweight, probability = TRUE)
curve(dnorm(x, mean = mean(brainweight), sd = sd(brainweight)),
add = TRUE, col = "blue")
#calculate values for analytical method
alpha <- 0.05
z <- qnorm(1 - alpha/2)
n <- length(brainweight)
sem <- mean(brainweight)/ sqrt(n)
#apply the formula
CI <- cbind("2.5%" = mean(brainweight) - z * sem,
"97.5%" =  mean(brainweight) + z * sem)
CI #Confidence interval
brainweight_young <- brainhead$brainweight[brainhead$agerange == 1]
brainweight_old <- brainhead$brainweight[brainhead$agerange == 2]
t.test(brainweight_young, brainweight_old, alternative = "two.sided")
folds
length(folds)
kfold <- function(k, data){
folds <- list()
m <- nrow(data) %/% k #group size
for(i in 1:k){
if(i == k){
folds[[i]] <- ((i-1)*m+1):(nrow(data))
}
else{
folds[[i]] <- ((i-1)*m + 1):(i*m)
}
}
return(folds)
}
k <- 10
folds <- kfold(k, brainhead)
length(folds)
folds
brainhead[-folds[[i]],]
brainhead[-folds[[i]],]
k <- 10
folds <- kfold(k, brainhead)
folds
leave10 <- function(folds, data){
output <- c()
for(i in 1:k){
fold_i <- sample(folds, replace = FALSE)
#fit model with all but i row
model_i <- lm("brainweight ~ headsize", data = brainhead[-fold_i,])
# predict value for row i
prediction_i <- predict(model_i, newdata = brainhead[fold_i,])
#check if prediction is good or not
se <- (prediction_i - brainhead$brainweight[fold_i])^2
##save it
output[i] <- mean(se)
}
return(mean(output))
}
leave10(brainhead)
folds
leave10(folds, brainhead)
